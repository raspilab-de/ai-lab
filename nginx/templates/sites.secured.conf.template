# HTTP -> HTTPS + ACME challenge
server {
  listen 80;
  server_name
    ${HOST}.${DOMAIN}
    n8n.${HOST}.${DOMAIN}
    s3.${HOST}.${DOMAIN};

  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  # Workflow files - static hosting
  location ^~ /workflows/ {
    alias /var/www/workflows/;
    autoindex off;

    # nur lesen
    limit_except GET HEAD { deny all; }
  }

  # function files - static hosting
  location ^~ /functions/ {
    alias /var/www/functions/;
    autoindex off;

    # nur lesen
    limit_except GET HEAD { deny all; }
  }
  
  # optional: ohne Slash sauber weiterleiten
  location = /workflows {
    return 301 /workflows/;
  }

  # optional: ohne Slash sauber weiterleiten
  location = /functions {
    return 301 /functions/;
  }

  location / {
    return 301 https://__NGX_HOST____NGX_URI__;
  }
}

# Open WebUI
server {
  listen 443 ssl http2;
  server_name ai-lab.raspilab.de;

  ssl_certificate     /etc/letsencrypt/live/${HOST}.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${HOST}.${DOMAIN}/privkey.pem;

  # Workflow files - static hosting
  location ^~ /workflows/ {
    alias /var/www/workflows/;
    autoindex off;

    # nur lesen
    limit_except GET HEAD { deny all; }
  }

  # function files - static hosting
  location ^~ /functions/ {
    alias /var/www/functions/;
    autoindex off;

    # nur lesen
    limit_except GET HEAD { deny all; }
  }
  
  # optional: ohne Slash sauber weiterleiten
  location = /workflows {
    return 301 /workflows/;
  }

  # optional: ohne Slash sauber weiterleiten
  location = /functions {
    return 301 /functions/;
  }

  location / {
    include /etc/nginx/snippets/proxy-common.conf;
    proxy_pass http://${UPSTREAM_OPENWEBUI};
  }
}

# n8n
server {
  listen 443 ssl http2;
  server_name n8n.ai-lab.raspilab.de;

  ssl_certificate     /etc/letsencrypt/live/${HOST}.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${HOST}.${DOMAIN}/privkey.pem;

  location / {
    include /etc/nginx/snippets/proxy-common.conf;
    proxy_pass http://${UPSTREAM_N8N};
  }
}

# Minio API
## /etc/nginx/keys/public.pem
server {
  listen 443 ssl http2;
  server_name s3.ai-lab.raspilab.de;

  ssl_certificate     /etc/letsencrypt/live/${HOST}.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${HOST}.${DOMAIN}/privkey.pem;

  location / {
    allow 172.30.10.0/24;
    deny all;

    include /etc/nginx/snippets/proxy-common.conf;
    proxy_pass http://${UPSTREAM_S3};
  }

  location /n8n/ {
    access_by_lua_block {
      local jwt = require("resty.jwt-verification")
      local token = ngx.var.arg_token

      if not token or token == "" then
        ngx.log(ngx.ERR, "No token")
        return ngx.exit(401)
      end

      token = ngx.unescape_uri(token)

      -- Public Key laden
      local f = io.open("/etc/nginx/keys/public.pem", "r")
      if not f then
        ngx.log(ngx.ERR, "Cannot read public key")
        return ngx.exit(500)
      end
      local pubkey = f:read("*a")
      f:close()

      -- JWT prüfen (Signatur + issuer + exp)
      local decoded, err = jwt.verify(token, pubkey, {
        valid_signing_algorithms = { ["RS256"] = "RS256" },
        issuer = "n8n-fileservice",
        ignore_expiration = true,
      })

      if not decoded then
        ngx.log(ngx.ERR, "JWT invalid: ", err or "nil")
        return ngx.exit(403)
      end

      -- Angefragtes Objekt aus URI ableiten
      local uri = ngx.var.uri  -- z.B. /n8n/AI-Lab.pdf
      local prefix = "/n8n/"
      if uri:sub(1, #prefix) ~= prefix then
        ngx.log(ngx.ERR, "Bad prefix uri=", uri)
        return ngx.exit(403)
      end

      local requested_object = uri:sub(#prefix + 1) -- "AI-Lab.pdf"
      if requested_object == "" then
        ngx.log(ngx.ERR, "Empty object")
        return ngx.exit(403)
      end

      -- Claims prüfen
      local p = decoded.payload or {}
      if p.bucket ~= "n8n" then
        ngx.log(ngx.ERR, "Bucket mismatch: ", tostring(p.bucket))
        return ngx.exit(403)
      end

      if p.object ~= requested_object then
        ngx.log(ngx.ERR, "Object mismatch: jwt=", tostring(p.object), " req=", requested_object)
        return ngx.exit(403)
      end

      ngx.log(ngx.INFO, "JWT OK: ", requested_object)
    }

    include /etc/nginx/snippets/proxy-common.conf;
    proxy_pass http://${UPSTREAM_S3};
  }
}
